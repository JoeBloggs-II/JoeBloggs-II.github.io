<!DOCTYPE html>
<html>
<body style="margin:0; background:black; display:flex; justify-content:center; align-items:center; height:100vh; overflow:hidden;">
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById("canvas");
const gl = canvas.getContext("webgl2");

let center = {x: -0.5, y: 0};
let zoom = 1.0;

// Resize canvas
function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const size = Math.min(window.innerWidth, window.innerHeight);
    canvas.style.width = size + "px";
    canvas.style.height = size + "px";
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ===== Shaders ===== */

const vertexShaderSource = `#version 300 es
in vec2 a_position;
void main() { gl_Position = vec4(a_position, 0.0, 1.0); }`;

const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 FragColor;
uniform vec2 iResolution;
uniform vec2 center;
uniform float zoom;

int mandelbrot(vec2 c, int maxIter) {
    vec2 z = vec2(0.0);
    int i;
    for(i=0; i<maxIter; i++) {
        float x = (z.x*z.x - z.y*z.y) + c.x;
        float y = (2.0*z.x*z.y) + c.y;
        z = vec2(x, y);
        if(dot(z,z) > 4.0) break;
    }
    return i;
}

vec3 palette(float t) {
    // Classic smooth Mandelbrot palette
    // Black interior, blue outer glow, soft highlights
    vec3 col;
    
    // Clamp for safety
    t = clamp(t, 0.0, 1.0);
const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 FragColor;
uniform vec2 iResolution;
uniform vec2 center;
uniform float zoom;

int mandelbrot(vec2 c, int maxIter) {
    vec2 z = vec2(0.0);
    int i;
    for(i=0; i<maxIter; i++) {
        float x = (z.x*z.x - z.y*z.y) + c.x;
        float y = (2.0*z.x*z.y) + c.y;
        z = vec2(x, y);
        if(dot(z,z) > 4.0) break;
    }
    return i;
}

vec3 palette(float t) {
    // Classic smooth Mandelbrot palette
    // Black interior, blue outer glow, soft highlights
    vec3 col;
    
    // Clamp for safety
    t = clamp(t, 0.0, 1.0);
const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 FragColor;
uniform vec2 iResolution;
uniform vec2 center;
uniform float zoom;

int mandelbrot(vec2 c, int maxIter) {
    vec2 z = vec2(0.0);
    int i;
    for(i=0; i<maxIter; i++) {
        float x = (z.x*z.x - z.y*z.y) + c.x;
        float y = (2.0*z.x*z.y) + c.y;
        z = vec2(x, y);
        if(dot(z,z) > 4.0) break;
    }
    return i;
}

vec3 palette(float t) {
    // Classic smooth Mandelbrot palette
    // Black interior, blue outer glow, soft highlights
    vec3 col;
    
    // Clamp for safety
    t = clamp(t, 0.0, 1.0);
const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 FragColor;
uniform vec2 iResolution;
uniform vec2 center;
uniform float zoom;

int mandelbrot(vec2 c, int maxIter) {
    vec2 z = vec2(0.0);
    int i;
    for(i=0; i<maxIter; i++) {
        float x = (z.x*z.x - z.y*z.y) + c.x;
        float y = (2.0*z.x*z.y) + c.y;
        z = vec2(x, y);
        if(dot(z,z) > 4.0) break;
    }
    return i;
}

vec3 palette(float t) {
    // Classic smooth Mandelbrot palette
    // Black interior, blue outer glow, soft highlights
    vec3 col;
    
    // Clamp for safety
    t = clamp(t, 0.0, 1.0);
const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 FragColor;

uniform vec2 iResolution;
uniform vec2 center;
uniform float zoom;

/* ===== Double-float support ===== */

struct df {
    float hi;
    float lo;
};

df df_make(float x) {
    return df(x, 0.0);
}

df df_add(df a, df b) {
    float s = a.hi + b.hi;
    float v = s - a.hi;
    float t = ((b.hi - v) + (a.hi - (s - v))) + a.lo + b.lo;
    return df(s, t);
}

df df_sub(df a, df b) {
    return df_add(a, df(-b.hi, -b.lo));
}

df df_mul(df a, df b) {
    float p = a.hi * b.hi;
    float e = a.hi * b.lo + a.lo * b.hi;
    return df(p, e);
}

float df_len2(df x, df y) {
    float hx = x.hi;
    float hy = y.hi;
    return hx*hx + hy*hy;
}

/* ===== Mandelbrot ===== */

int mandelbrot_df(df cx, df cy, int maxIter) {
    df zx = df_make(0.0);
    df zy = df_make(0.0);

    int i;
    for (i = 0; i < maxIter; i++) {
        df zx2 = df_mul(zx, zx);
        df zy2 = df_mul(zy, zy);

        df x = df_add(df_sub(zx2, zy2), cx);
        df y = df_add(df_mul(df_make(2.0), df_mul(zx, zy)), cy);

        zx = x;
        zy = y;

        if (df_len2(zx, zy) > 4.0) break;
    }
    return i;
}

/* ===== Palette ===== */

vec3 palette(float t) {
    t = clamp(t, 0.0, 1.0);
    return vec3(
        9.0*(1.0-t)*t*t*t,
        15.0*(1.0-t)*(1.0-t)*t*t,
        8.5*(1.0-t)*(1.0-t)*(1.0-t)*t
    );
}

/* ===== Main ===== */

void main() {
    vec2 uv = (gl_FragCoord.xy / iResolution) * 3.0 - vec2(2.0, 1.5);
    uv.x *= iResolution.x / iResolution.y;

    int maxIter = int(200.0 + 300.0 * log2(zoom));

    // Threshold where float precision breaks down
    bool highPrecision = zoom > 1e6;

    int iter;

    if (!highPrecision) {
        // Fast path (float)
        vec2 c = center + uv / zoom;
        vec2 z = vec2(0.0);

        int i;
        for (i = 0; i < maxIter; i++) {
            z = vec2(
                z.x*z.x - z.y*z.y,
                2.0*z.x*z.y
            ) + c;

            if (dot(z, z) > 4.0) break;
        }
        iter = i;
    } else {
        // High-precision path
        df cx = df_add(df_make(center.x), df_make(uv.x / zoom));
        df cy = df_add(df_make(center.y), df_make(uv.y / zoom));
        iter = mandelbrot_df(cx, cy, maxIter);
    }

    float t = float(iter) / float(maxIter);
    FragColor = vec4(palette(t), 1.0);
}`;

// Compile
function compileShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(shader));
    return shader;
}

const program = gl.createProgram();
gl.attachShader(program, compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource));
gl.attachShader(program, compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource));
gl.linkProgram(program);
gl.useProgram(program);

// Fullscreen quad
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1,
    -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);

const positionLocation = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

// Uniforms
const resLoc = gl.getUniformLocation(program, "iResolution");
const centerLoc = gl.getUniformLocation(program, "center");
const zoomLoc = gl.getUniformLocation(program, "zoom");

/* ===== Coordinate helper ===== */

function screenToComplex(px, py) {
    const rect = canvas.getBoundingClientRect();
    const x = (px - rect.left) / rect.width;
    const y = (py - rect.top) / rect.height;

    let u = x * 3.0 - 2.0;
    let v = y * 3.0 - 1.5;
    u *= canvas.width / canvas.height;

    return {
        x: center.x + u / zoom,
        y: center.y + v / zoom
    };
}

function zoomAt(px, py, factor) {
    const before = screenToComplex(px, py);
    zoom *= factor;
    const after = screenToComplex(px, py);

    center.x += before.x - after.x;
    center.y += before.y - after.y;
}

/* ===== Mouse pan ===== */

let isDragging = false, lastX, lastY;

canvas.addEventListener('mousedown', e => {
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
});
canvas.addEventListener('mouseup', () => isDragging = false);

canvas.addEventListener('mousemove', e => {
    if(isDragging) {
        const dx = (e.clientX - lastX)/canvas.width*3.0/zoom;
        const dy = (e.clientY - lastY)/canvas.height*3.0/zoom;
        center.x -= dx * (canvas.width / canvas.height);
        center.y += dy;
        lastX = e.clientX;
        lastY = e.clientY;
    }
});

/* ===== Mouse zoom (fixed) ===== */

canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.2 : 0.8;
    zoomAt(e.clientX, e.clientY, factor);
}, { passive:false });

/* ===== Touch ===== */

let lastTouchDist = null;

canvas.addEventListener('touchmove', e => {
    e.preventDefault();

    if(e.touches.length === 1) {
        const t = e.touches[0];
        const dx = (t.clientX - lastX)/canvas.width*3.0/zoom;
        const dy = (t.clientY - lastY)/canvas.height*3.0/zoom;
        center.x -= dx * (canvas.width / canvas.height);
        center.y += dy;
        lastX = t.clientX;
        lastY = t.clientY;
    }

    if(e.touches.length === 2) {
        const t1 = e.touches[0];
        const t2 = e.touches[1];

        const dx = t1.clientX - t2.clientX;
        const dy = t1.clientY - t2.clientY;
        const dist = Math.hypot(dx, dy);

        const midX = (t1.clientX + t2.clientX)/2;
        const midY = (t1.clientY + t2.clientY)/2;

        if(lastTouchDist !== null) {
            const factor = dist / lastTouchDist;
            zoomAt(midX, midY, factor);
        }

        lastTouchDist = dist;
    }
}, { passive:false });

canvas.addEventListener('touchstart', e => {
    if(e.touches.length === 1) {
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
    }
});

canvas.addEventListener('touchend', () => lastTouchDist = null);

/* ===== Render ===== */

function render() {
    gl.uniform2f(resLoc, canvas.width, canvas.height);
    gl.uniform2f(centerLoc, center.x, center.y);
    gl.uniform1f(zoomLoc, zoom);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
}
render();
</script>
</body>
</html>

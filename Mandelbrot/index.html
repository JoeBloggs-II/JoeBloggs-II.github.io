<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mandelbrot Explorer</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; }
    canvas { display: block; width: 100%; height: 100%; touch-action: none; }
    #controls {
      position: absolute; top: 10px; left: 10px;
      background: rgba(255, 255, 255, 0.8);
      padding: 10px;
      font-family: sans-serif;
      border-radius: 8px;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="controls">
  Max Iterations: <input id="iterSlider" type="range" min="50" max="1000" value="100">
  <span id="iterLabel">100</span>
</div>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let width, height;

let zoom = 200;
let offsetX = 0;
let offsetY = 0;
let maxIter = 100;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  width = canvas.width;
  height = canvas.height;
  draw();
}
window.addEventListener("resize", resize);
resize();

document.getElementById("iterSlider").oninput = e => {
  maxIter = parseInt(e.target.value);
  document.getElementById("iterLabel").textContent = maxIter;
  draw();
};

function draw() {
  const imgData = ctx.createImageData(width, height);
  const data = imgData.data;

  for (let py = 0; py < height; py++) {
    for (let px = 0; px < width; px++) {
      let x0 = (px - width / 2 + offsetX) / zoom;
      let y0 = (py - height / 2 + offsetY) / zoom;
      let x = 0, y = 0, iter = 0;

      while (x * x + y * y <= 4 && iter < maxIter) {
        const xtemp = x * x - y * y + x0;
        y = 2 * x * y + y0;
        x = xtemp;
        iter++;
      }

      const index = 4 * (py * width + px);
      const ratio = iter / maxIter;
      data[index] = 9 * (1 - ratio) * ratio * 255;    // R
      data[index + 1] = 15 * (1 - ratio) * ratio * 255; // G
      data[index + 2] = 8.5 * (1 - ratio) * ratio * 255; // B
      data[index + 3] = 255;
    }
  }
  ctx.putImageData(imgData, 0, 0);
}

canvas.addEventListener("wheel", e => {
  const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
  const mx = e.offsetX - width / 2;
  const my = e.offsetY - height / 2;
  offsetX = mx + (offsetX - mx) * zoomFactor;
  offsetY = my + (offsetY - my) * zoomFactor;
  zoom *= zoomFactor;
  draw();
});

let dragging = false, lastX, lastY;
canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});
canvas.addEventListener("mouseup", () => dragging = false);
canvas.addEventListener("mousemove", e => {
  if (!dragging) return;
  offsetX += e.clientX - lastX;
  offsetY += e.clientY - lastY;
  lastX = e.clientX;
  lastY = e.clientY;
  draw();
});

// Touch support
let pinchStartDist = null, pinchStartZoom = null;
canvas.addEventListener("touchstart", e => {
  if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    pinchStartDist = Math.hypot(dx, dy);
    pinchStartZoom = zoom;
  } else if (e.touches.length === 1) {
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  }
}, { passive: false });

canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const newDist = Math.hypot(dx, dy);
    const zoomFactor = newDist / pinchStartDist;
    zoom = pinchStartZoom * zoomFactor;
    draw();
  } else if (e.touches.length === 1) {
    const cx = e.touches[0].clientX;
    const cy = e.touches[0].clientY;
    offsetX += cx - lastX;
    offsetY += cy - lastY;
    lastX = cx;
    lastY = cy;
    draw();
  }
}, { passive: false });
</script>
</body>
</html>

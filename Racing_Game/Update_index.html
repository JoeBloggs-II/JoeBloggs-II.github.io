<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Turbo Trackers — Drift Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  html, body { margin:0; overflow:hidden; background:#111; height:100%; }
  canvas { display:block; background:#222; width:100vw; height:100vh; }
  #controls { position:fixed; bottom:10px; left:50%; transform:translateX(-50%); display:flex; gap:10px; z-index:10; user-select:none;}
  .btn { width:60px; height:60px; border-radius:50%; background: rgba(255,255,255,0.1); border:2px solid #fff; color:white; font-size:24px; display:flex; align-items:center; justify-content:center; touch-action: manipulation; }
  #minimap { position:fixed; top:10px; right:10px; width:150px; height:150px; background:#111; border:2px solid #fff; z-index:11;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<canvas id="minimap"></canvas>
<div id="controls">
  <button class="btn" id="left">⟵</button>
  <button class="btn" id="up">↑</button>
  <button class="btn" id="down">↓</button>
  <button class="btn" id="right">⟶</button>
</div>
<script src="https://cdn.ably.io/lib/ably.min-1.js"></script>
<script>
const API_KEY = "Nllp5A.3TYLaQ:G74XydAZRQIJ0-IwWsjhBj6HNcaeiYjdyWUc4zq1TiE";
const ROOM = "racing-room";

// Canvas setup
const canvas = document.getElementById("game"), ctx = canvas.getContext("2d");
const mini = document.getElementById("minimap"), mctx = mini.getContext("2d");
function resize() { canvas.width=window.innerWidth; canvas.height=window.innerHeight; mini.width=150; mini.height=150; }
window.addEventListener("resize", resize); resize();

// Track setup
const TRACK = {
  path: [
    {x:200,y:200},{x:1800,y:200},{x:1800,y:1200},{x:200,y:1200} // rectangle loop, you can add curves later
  ],
  width:80,
  boostPads:[ {x:500,y:200,w:100,h:40}, {x:1400,y:1200,w:100,h:40} ],
  obstacles:[ {x:900,y:700,w:50,h:50}, {x:1300,y:400,w:60,h:60} ]
};

// Car assets
const carImage = new Image(); carImage.src = "assets/red_car.svg";
const carOtherImage = new Image(); carOtherImage.src = "assets/blue_car.svg";

// Ably
const ably = new Ably.Realtime(API_KEY); const channel = ably.channels.get(ROOM);

// Player
const me = { id: Math.random().toString(36).substr(2,5), x:250, y:250, angle:0, speed:0, keys:{}, drift:0 };
const others = {};

// Input
const keys = {}; document.addEventListener("keydown", e=>{keys[e.key]=true;}); document.addEventListener("keyup", e=>{keys[e.key]=false;});
// Mobile controls
const controls={left:document.getElementById("left"),up:document.getElementById("up"),down:document.getElementById("down"),right:document.getElementById("right")};
Object.entries(controls).forEach(([dir,btn])=>{
  btn.addEventListener("touchstart",e=>{e.preventDefault();keys[dir]=true;},{passive:false});
  btn.addEventListener("touchend",e=>{e.preventDefault();keys[dir]=false;},{passive:false});
});

// Networking history
const INTERP_DELAY_MS = 120, MAX_HISTORY = 20, MAX_EXTRAP_MS = 250, SEND_INTERVAL_MS=50;
function pushHistory(id,sample){ let o=others[id]; if(!o)o=others[id]={history:[],lastSeen:sample.time}; o.history.push(sample); o.lastSeen=sample.time; if(o.history.length>MAX_HISTORY)o.history.shift();}
function angleLerp(a,b,t){let diff=((b-a+Math.PI)%(2*Math.PI)+2*Math.PI)%(2*Math.PI)-Math.PI;return a+diff*t;}
function getInterpolatedState(history,now){ if(!history||history.length===0)return null; const renderTime=now-INTERP_DELAY_MS; if(renderTime<=history[0].time)return history[0]; for(let i=history.length-2;i>=0;i--){const older=history[i],newer=history[i+1];if(older.time<=renderTime&&renderTime<=newer.time){const t=(renderTime-older.time)/(newer.time-older.time); return {x:older.x+(newer.x-older.x)*t,y:older.y+(newer.y-older.y)*t,angle:angleLerp(older.angle,newer.angle,t)}}} const last=history[history.length-1], prev=history[history.length-2]||last; const dt=Math.max(1,last.time-prev.time); const vx=(last.x-prev.x)/dt, vy=(last.y-prev.y)/dt, va=(last.angle-prev.angle)/dt; const ahead=Math.min(MAX_EXTRAP_MS,renderTime-last.time); return {x:last.x+vx*ahead,y:last.y+vy*ahead,angle:last.angle+va*ahead};}
channel.subscribe("player-state",msg=>{const{id,x,y,angle}=msg.data||{}; if(!id||id===me.id)return; pushHistory(id,{x,y,angle,time:performance.now()});});

// Particle system
const particles=[];
function emitDrift(x,y,angle){particles.push({x,y,angle,life:30});}
function updateParticles(){for(let i=particles.length-1;i>=0;i--){particles[i].life--; if(particles[i].life<=0)particles.splice(i,1); else{particles[i].x+=Math.cos(particles[i].angle+Math.PI/2)*0.5; particles[i].y+=Math.sin(particles[i].angle+Math.PI/2)*0.5;}}}
function drawParticles(){particles.forEach(p=>{ctx.fillStyle=`rgba(255,255,255,${p.life/30})`; ctx.fillRect(p.x-2,p.y-2,4,4);});}

// Physics
const ACCEL=0.2, TURN=0.05, FRICTION=0.96, DRIFT_FACTOR=0.3;

// Game loop
let lastFrame=performance.now(), lastSent=0;
function loop(now){
  const dt=(now-lastFrame)/1000; const scale=dt*60;
  // Input
  if(keys["ArrowUp"]||keys.w||keys.up) me.speed+=ACCEL*scale;
  if(keys["ArrowDown"]||keys.s||keys.down) me.speed-=ACCEL*scale;
  if(keys["ArrowLeft"]||keys.a||keys.left){ me.angle-=TURN*scale; if(me.speed>2) me.drift+=DRIFT_FACTOR; }
  if(keys["ArrowRight"]||keys.d||keys.right){ me.angle+=TURN*scale; if(me.speed>2) me.drift+=DRIFT_FACTOR; }
  me.speed*=Math.pow(FRICTION,scale);
  me.x+=Math.cos(me.angle)*me.speed*scale;
  me.y+=Math.sin(me.angle)*me.speed*scale;
  if(me.drift>0){ emitDrift(me.x,me.y,me.angle); me.drift*=0.9; }

  // Boost pad detection
  TRACK.boostPads.forEach(b=>{if(me.x>b.x && me.x<b.x+b.w && me.y>b.y && me.y<b.y+b.h) me.speed+=0.5;});

  // Send state
  if(now-lastSent>SEND_INTERVAL_MS){ channel.publish("player-state",{id:me.id,x:me.x,y:me.y,angle:me.angle}); lastSent=now; }

  // Cull stale players
  for(const id in others) if(now-others[id].lastSeen>3000) delete others[id];

  // Camera
  const camX=me.x-canvas.width/2; const camY=me.y-canvas.height/2;

  // Draw
  ctx.fillStyle="#333"; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.translate(-camX,-camY);
  // Track
  ctx.fillStyle="#555"; ctx.strokeStyle="#fff"; ctx.lineWidth=5;
  ctx.beginPath(); ctx.moveTo(TRACK.path[0].x,TRACK.path[0].y);
  for(let i=1;i<TRACK.path.length;i++) ctx.lineTo(TRACK.path[i].x,TRACK.path[i].y);
  ctx.closePath(); ctx.fill(); ctx.stroke();
  // Obstacles
  ctx.fillStyle="orange"; TRACK.obstacles.forEach(o=>ctx.fillRect(o.x,o.y,o.w,o.h));
  // Boost pads
  ctx.fillStyle="lime"; TRACK.boostPads.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));
  // Particles
  drawParticles();
  // Cars
  drawCar(me.x,me.y,me.angle,carImage);
  for(const id in others){const s=getInterpolatedState(others[id].history,now); if(s) drawCar(s.x,s.y,s.angle,carOtherImage);}
  ctx.restore();

  // Minimap
  mctx.clearRect(0,0,mini.width,mini.height);
  mctx.fillStyle="#222"; mctx.fillRect(0,0,mini.width,mini.height);
  // Track outline
  mctx.strokeStyle="#fff"; mctx.lineWidth=2; mctx.beginPath(); mctx.moveTo(TRACK.path[0].x/15,TRACK.path[0].y/15);
  for(let i=1;i<TRACK.path.length;i++) mctx.lineTo(TRACK.path[i].x/15,TRACK.path[i].y/15); mctx.closePath(); mctx.stroke();
  // Cars
  mctx.fillStyle="red"; mctx.fillRect(me.x/15-2,me.y/15-2,4,4);
  mctx.fillStyle="blue"; for(const id in others){const s=getInterpolatedState(others[id].history,now); if(s)mctx.fillRect(s.x/15-2,s.y/15-2,4,4);}
  
  updateParticles();
  lastFrame=now; requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>

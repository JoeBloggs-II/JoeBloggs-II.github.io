<!DOCTYPE html>
<html>
<body style="margin:0; background:black; overflow:hidden;">
<canvas id="canvas"></canvas>
<div id="zoomDisplay" style="
    position:absolute;
    top:10px;
    left:10px;
    color:white;
    font-family:monospace;
    background:rgba(0,0,0,0.5);
    padding:4px 8px;
    border-radius:4px;
"></div>

<script>
const canvas = document.getElementById("canvas");
const gl = canvas.getContext("webgl2");
const zoomDisplay = document.getElementById("zoomDisplay");

let center = { x: -0.5, y: 0.0 };
let zoom = 1.5;

/* ===== Resize ===== */

function resize() {
    const dpr = window.devicePixelRatio || 1;
    const size = Math.min(innerWidth, innerHeight);
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    canvas.style.width = size + "px";
    canvas.style.height = size + "px";
    gl.viewport(0, 0, canvas.width, canvas.height);
}
addEventListener("resize", resize);
resize();

/* ===== Shaders ===== */

const vs = `#version 300 es
in vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

const fs = `#version 300 es
precision highp float;
out vec4 FragColor;

uniform vec2 iResolution;
uniform vec4 center_df;   // x.hi, x.lo, y.hi, y.lo
uniform float zoom;

/* ===== double-float ===== */

struct df { float hi; float lo; };

df df_make(float x) { return df(x, 0.0); }

df df_add(df a, df b) {
    float s = a.hi + b.hi;
    float v = s - a.hi;
    float t = ((b.hi - v) + (a.hi - (s - v))) + a.lo + b.lo;
    return df(s, t);
}

df df_sub(df a, df b) {
    return df_add(a, df(-b.hi, -b.lo));
}

df df_mul(df a, df b) {
    float p = a.hi * b.hi;
    float e = a.hi * b.lo + a.lo * b.hi;
    return df(p, e);
}

float df_len2(df x, df y) {
    float a = x.hi*x.hi + y.hi*y.hi;
    float b = 2.0*(x.hi*x.lo + y.hi*y.lo);
    return a + b;
}

/* ===== Mandelbrot ===== */

int mandelbrot(df cx, df cy, int maxIter) {
    df zx = df_make(0.0);
    df zy = df_make(0.0);

    int i;
    for (i = 0; i < maxIter; i++) {
        df zx2 = df_mul(zx, zx);
        df zy2 = df_mul(zy, zy);

        df x = df_add(df_sub(zx2, zy2), cx);
        df y = df_add(df_mul(df_make(2.0), df_mul(zx, zy)), cy);

        zx = x;
        zy = y;

        if (df_len2(zx, zy) > 4.0) break;
    }
    return i;
}

/* ===== Palette ===== */

vec3 palette(float t) {
    t = clamp(t, 0.0, 1.0);
    return vec3(
        9.0*(1.0-t)*t*t*t,
        15.0*(1.0-t)*(1.0-t)*t*t,
        8.5*(1.0-t)*(1.0-t)*(1.0-t)*t
    );
}

/* ===== Main ===== */

void main() {
    vec2 p = gl_FragCoord.xy / iResolution;
    vec2 uv = vec2(
        p.x * 3.0 - 2.0,
        p.y * 3.0 - 1.5
    );
    uv.x *= iResolution.x / iResolution.y;

    float scale = 1.0 / zoom;

    df cx = df_add(
        df(center_df.x, center_df.y),
        df_make(uv.x * scale)
    );
    df cy = df_add(
        df(center_df.z, center_df.w),
        df_make(uv.y * scale)
    );

    int maxIter = int(200.0 + 300.0 * log2(zoom));
    int iter = mandelbrot(cx, cy, maxIter);

    float t = float(iter) / float(maxIter);
    FragColor = vec4(palette(t), 1.0);
}
`;

/* ===== Compile ===== */

function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(s));
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
gl.useProgram(prog);

/* ===== Quad ===== */

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1,
    -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(prog, "a_position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

/* ===== Uniforms ===== */

const resLoc = gl.getUniformLocation(prog, "iResolution");
const centerLoc = gl.getUniformLocation(prog, "center_df");
const zoomLoc = gl.getUniformLocation(prog, "zoom");

/* ===== Interaction ===== */

function screenToComplex(x, y) {
    const r = canvas.getBoundingClientRect();
    const u = (x - r.left) / r.width;
    const v = (y - r.top) / r.height;

    let px = u*3.0 - 2.0;
    let py = v*3.0 - 1.5;
    px *= canvas.width / canvas.height;

    return {
        x: center.x + px / zoom,
        y: center.y + py / zoom
    };
}

function zoomAt(x, y, f) {
    const a = screenToComplex(x, y);
    zoom *= f;
    const b = screenToComplex(x, y);
    center.x += a.x - b.x;
    center.y += a.y - b.y;
}

let drag = false, lx, ly;

canvas.onmousedown = e => { drag = true; lx = e.clientX; ly = e.clientY; };
onmouseup = () => drag = false;

canvas.onmousemove = e => {
    if (!drag) return;
    const dx = (e.clientX - lx) / canvas.width * 3.0 / zoom;
    const dy = (e.clientY - ly) / canvas.height * 3.0 / zoom;
    center.x -= dx * (canvas.width / canvas.height);
    center.y += dy;
    lx = e.clientX;
    ly = e.clientY;
};

canvas.onwheel = e => {
    e.preventDefault();
    zoomAt(e.clientX, e.clientY, e.deltaY < 0 ? 1.2 : 0.8);
};

/* ===== Render ===== */

function render() {
    gl.uniform2f(resLoc, canvas.width, canvas.height);
    gl.uniform4f(centerLoc, center.x, 0.0, center.y, 0.0);
    gl.uniform1f(zoomLoc, zoom);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    zoomDisplay.textContent = "Zoom: " + zoom.toExponential(3);
    requestAnimationFrame(render);
}
render();
</script>
</body>
</html>

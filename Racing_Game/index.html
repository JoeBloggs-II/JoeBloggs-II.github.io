<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Turbo Trackers Multiplayer</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  html, body { margin: 0; overflow: hidden; background: #111; height: 100%; }
  canvas { display: block; background: #222; width: 100vw; height: 100vh; }
  #hud {
    position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 40px; color: white; font-family: sans-serif;
    font-size: 18px; font-weight: bold; z-index: 10;
  }
  .health-bar {
    width: 120px; height: 12px; background: #444; border: 1px solid white;
    position: relative;
  }
  .health-fill {
    height: 100%; background: lime; width: 100%;
  }
</style>
</head>
<body>
<div id="hud">
  <div>P1 <div class="health-bar"><div class="health-fill" id="p1Health"></div></div></div>
  <div>P2 <div class="health-bar"><div class="health-fill" id="p2Health"></div></div></div>
</div>
<canvas id="game"></canvas>
<script src="https://cdn.ably.io/lib/ably.min-1.js"></script>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener("resize", resize);
resize();

// --- Assets ---
const carImage = new Image();
carImage.src = "assets/red_car.svg";
const carOtherImage = new Image();
carOtherImage.src = "assets/blue_car.svg";

// --- Multiplayer ---
const API_KEY = "Nllp5A.3TYLaQ:G74XydAZRQIJ0-IwWsjhBj6HNcaeiYjdyWUc4zq1TiE";
const ROOM = "racing-room";
const ably = new Ably.Realtime(API_KEY);
const channel = ably.channels.get(ROOM);

// --- Player state ---
const me = { id: Math.random().toString(36).substr(2,5), x: Math.random()*canvas.width, y: Math.random()*canvas.height, angle: 0, speed: 0, health:100, keys:{}, stunned:0 };
const others = {}; // id -> { history: [{x,y,angle,speed,time}], health, lastSeen }

// --- Input ---
const keyMap = {ArrowUp:"up",ArrowDown:"down",ArrowLeft:"left",ArrowRight:"right",w:"up",s:"down",a:"left",d:"right",Shift:"drift"};
document.addEventListener("keydown", e=>{if(keyMap[e.key]) me.keys[keyMap[e.key]]=true;});
document.addEventListener("keyup", e=>{if(keyMap[e.key]) me.keys[keyMap[e.key]]=false;});

// --- Particle system ---
const particles = [];
class Particle {
  constructor(x,y,color,size,life,velX,velY){this.x=x;this.y=y;this.color=color;this.size=size;this.life=life;this.velX=velX||0;this.velY=velY||0;}
  update(){this.life--; this.x+=this.velX; this.y+=this.velY;}
  draw(){ctx.fillStyle=this.color; ctx.globalAlpha=this.life/30; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;}
}

// --- Helpers ---
function drawCar(x,y,angle,image){ctx.save(); ctx.translate(x,y); ctx.rotate(angle); ctx.drawImage(image,-48,-23.8,96,47.6); ctx.restore();}
function pushHistory(id,sample){let o=others[id]; if(!o)o=others[id]={history:[],health:100,lastSeen:sample.time}; o.history.push(sample); o.lastSeen=sample.time; if(o.history.length>20)o.history.shift();}
function getInterpolatedState(history,now){if(!history||history.length===0)return null; const renderTime=now-120; for(let i=history.length-2;i>=0;i--){const older=history[i],newer=history[i+1]; if(older.time<=renderTime && renderTime<=newer.time){const t=(renderTime-older.time)/(newer.time-older.time||1); return {x:older.x+(newer.x-older.x)*t, y:older.y+(newer.y-older.y)*t, angle:older.angle+(newer.angle-older.angle)*t, speed:older.speed+(newer.speed-older.speed)*t};}} const last=history[history.length-1]; return last;}

// --- Networking receive ---
channel.subscribe("player-state",(msg)=>{const{ id,x,y,angle,speed,health}=msg.data||{}; if(!id||id===me.id) return; pushHistory(id,{x,y,angle,speed,time:performance.now()}); others[id].health=health;});

// --- Collision detection ---
function collideCars(c1,c2){
  const dx=c2.x-c1.x, dy=c2.y-c1.y;
  const dist=Math.sqrt(dx*dx+dy*dy);
  if(dist<60){
    // Determine collision type
    const dir=Math.atan2(dy,dx);
    const diff=Math.abs((c1.angle-dir+Math.PI)%(2*Math.PI)-Math.PI);
    const headOn=diff>Math.PI/3; // approx
    const impactSpeed=Math.abs(c1.speed-c2.speed);

    if(headOn){
      const dmg=Math.floor(impactSpeed*15);
      c1.health-=dmg; c2.health-=dmg;
    } else {
      if(c1.speed>c2.speed) c2.health-=Math.floor(c1.speed*10);
      else if(c2.speed>c1.speed) c1.health-=Math.floor(c2.speed*10);
    }

    // Knockback
    const knock=10;
    c1.x-=Math.cos(dir)*knock; c1.y-=Math.sin(dir)*knock; c2.x+=Math.cos(dir)*knock; c2.y+=Math.sin(dir)*knock;
    c1.stunned=15; c2.stunned=15;

    // Particles
    for(let i=0;i<15;i++){particles.push(new Particle(c1.x,c1.y,"orange",3,30,(Math.random()-0.5)*5,(Math.random()-0.5)*5));}
  }
}

// --- Game loop ---
let lastFrame=performance.now(), lastSent=0;
function loop(now){
  const dt=(now-lastFrame)/1000;
  const frameScale=dt*60;

  // Input â†’ physics
  if(me.stunned>0){me.stunned--; me.speed*=0.95;} else {
    if(me.keys.up) me.speed+=0.25*frameScale;
    if(me.keys.down) me.speed-=0.15*frameScale;
    if(me.keys.left) me.angle-=0.04*frameScale*(me.speed/3);
    if(me.keys.right) me.angle+=0.04*frameScale*(me.speed/3);
    if(me.keys.drift){for(let i=0;i<2;i++)particles.push(new Particle(me.x,me.y,"yellow",2,15,(Math.random()-0.5)*2,(Math.random()-0.5)*2));}
  }

  // Friction & speed cap
  me.speed*=0.96;
  me.speed=Math.max(Math.min(me.speed,6),-3);

  me.x+=Math.cos(me.angle)*me.speed*frameScale;
  me.y+=Math.sin(me.angle)*me.speed*frameScale;

  // Wrap around screen
  if(me.x<-60) me.x=canvas.width+60;
  if(me.x>canvas.width+60) me.x=-60;
  if(me.y<-60) me.y=canvas.height+60;
  if(me.y>canvas.height+60) me.y=-60;

  // Update others (interpolation)
  for(const id in others){
    const s=getInterpolatedState(others[id].history,now);
    if(s){others[id].x=s.x; others[id].y=s.y; others[id].angle=s.angle; others[id].speed=s.speed;}
    if(now-others[id].lastSeen>3000) delete others[id];
  }

  // Collisions
  for(const id in others) collideCars(me, others[id]);

  // Draw
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawCar(me.x,me.y,me.angle,carImage);
  for(const id in others) drawCar(others[id].x,others[id].y,others[id].angle,carOtherImage);

  // Update particles
  for(let i=particles.length-1;i>=0;i--){particles[i].update(); particles[i].draw(); if(particles[i].life<=0)particles.splice(i,1);}

  // Update HUD
  document.getElementById("p1Health").style.width=Math.max(0,me.health)+"%";
  for(const id in others){document.getElementById("p2Health").style.width=Math.max(0,others[id].health)+"%"; break;}

  // Send state periodically
  if(now-lastSent>50){
    channel.publish("player-state",{id:me.id,x:me.x,y:me.y,angle:me.angle,speed:me.speed,health:me.health});
    lastSent=now;
  }

  lastFrame=now;
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Mandelbrot â€“ Stable Baseline</title>
<style>
html, body {
    margin: 0;
    background: black;
    overflow: hidden;
}
canvas {
    display: block;
}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl");

if (!gl) {
    alert("WebGL not supported");
}

/* ---------- Resize ---------- */

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = innerWidth  * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width  = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    gl.viewport(0, 0, canvas.width, canvas.height);
}
addEventListener("resize", resize);
resize();

/* ---------- Shaders ---------- */

const vs = `
attribute vec2 pos;
varying vec2 vUV;

void main() {
    vUV = pos;
    gl_Position = vec4(pos, 0.0, 1.0);
}
`;

const fs = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif

varying vec2 vUV;

uniform vec2 resolution;
uniform vec2 center;
uniform float zoom;

void main() {
    vec2 uv = vUV;
    uv.x *= resolution.x / resolution.y;

    vec2 c = center + uv / zoom;
    vec2 z = vec2(0.0);

    int iter;
    const int MAX = 200;

    for (int i = 0; i < MAX; i++) {
        z = vec2(
            z.x*z.x - z.y*z.y,
            2.0*z.x*z.y
        ) + c;

        if (dot(z, z) > 4.0) {
            iter = i;
            break;
        }
        iter = MAX;
    }

    float t = float(iter) / float(MAX);
    vec3 col = vec3(
        0.5 + 0.5*cos(3.0 + t*6.0),
        0.5 + 0.5*cos(1.0 + t*6.0),
        0.5 + 0.5*cos(5.0 + t*6.0)
    );

    gl_FragColor = vec4(col, 1.0);
}
`;

function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(s));
    }
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
gl.useProgram(prog);

/* ---------- Geometry ---------- */

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([
        -1,-1,  1,-1, -1, 1,
        -1, 1,  1,-1,  1, 1
    ]),
    gl.STATIC_DRAW
);

const posLoc = gl.getAttribLocation(prog, "pos");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

/* ---------- Uniforms ---------- */

const resLoc    = gl.getUniformLocation(prog, "resolution");
const centerLoc = gl.getUniformLocation(prog, "center");
const zoomLoc   = gl.getUniformLocation(prog, "zoom");

/* ---------- State ---------- */

let center = { x: -0.5, y: 0.0 };
let zoom = 1.0;

/* ---------- Mouse ---------- */

let dragging = false;
let lastX = 0, lastY = 0;

canvas.onmousedown = e => {
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
};

canvas.onmouseup = () => dragging = false;

canvas.onmousemove = e => {
    if (!dragging) return;
    const dx = (e.clientX - lastX) / canvas.width * 2.0 / zoom;
    const dy = (e.clientY - lastY) / canvas.height * 2.0 / zoom;
    center.x -= dx * (canvas.width / canvas.height);
    center.y += dy;
    lastX = e.clientX;
    lastY = e.clientY;
};

canvas.onwheel = e => {
    e.preventDefault();
    zoom *= e.deltaY < 0 ? 1.2 : 0.8;
};

/* ---------- Render ---------- */

function draw() {
    gl.uniform2f(resLoc, canvas.width, canvas.height);
    gl.uniform2f(centerLoc, center.x, center.y);
    gl.uniform1f(zoomLoc, zoom);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>

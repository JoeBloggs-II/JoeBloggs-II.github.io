<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Mandelbrot Deep Zoom (Split Float)</title>
<style>
html, body { margin: 0; height: 100%; background: black; }
canvas { width: 100%; height: 100%; display: block; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl");
if (!gl) alert("WebGL not supported");

// Resize
function resize() {
    canvas.width = innerWidth;
    canvas.height = innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
addEventListener("resize", resize);
resize();

// ---------- SHADERS ----------
const vertSrc = `
attribute vec2 pos;
varying vec2 vUV;
void main() {
    vUV = pos;
    gl_Position = vec4(pos, 0.0, 1.0);
}
`;

const fragSrc = `
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
varying vec2 vUV;

uniform vec2 centerHi;
uniform vec2 centerLo;
uniform float zoom;
uniform vec2 resolution;

#define MAX_ITER 500

// double-float
struct df { float hi; float lo; };

df make_df(float x) {
    df r;
    r.hi = x;
    r.lo = 0.0;
    return r;
}

df add(df a, df b) {
    float s = a.hi + b.hi;
    float v = s - a.hi;
    float t = ((b.hi - v) + (a.hi - (s - v))) + a.lo + b.lo;
    df r;
    r.hi = s + t;
    r.lo = t - (r.hi - s);
    return r;
}

df mul(df a, df b) {
    float p = a.hi * b.hi;
    float e = a.hi * b.lo + a.lo * b.hi;
    df r;
    r.hi = p + e;
    r.lo = e - (r.hi - p);
    return r;
}

float df_len2(df x, df y) {
    return x.hi*x.hi + y.hi*y.hi;
}

void main() {
    // Correct aspect handling
    vec2 uv = vUV;
    uv.x *= resolution.x / resolution.y;

    // Build high-precision center
    df cx = add(make_df(centerHi.x), make_df(centerLo.x));
    df cy = add(make_df(centerHi.y), make_df(centerLo.y));

    // Pixel scale
    float scale = 1.0 / zoom;

    df x = add(cx, make_df(uv.x * scale));
    df y = add(cy, make_df(uv.y * scale));

    df zx = make_df(0.0);
    df zy = make_df(0.0);

    for (int i = 0; i < MAX_ITER; i++) {
        df zx2 = mul(zx, zx);
        df zy2 = mul(zy, zy);
        if (zx2.hi + zy2.hi > 4.0) break;
        
        df nzx = add(add(zx2, mul(make_df(-1.0), zy2)), x);
        df nzy = add(mul(make_df(2.0), mul(zx, zy)), y);

        zx = nzx;
        zy = nzy;
    }

    float t = float(i) / float(MAX_ITER);
    vec3 col = vec3(t*t, t, 1.0 - t);
    gl_FragColor = vec4(col, 1.0);
}
`;

// ---------- PROGRAM ----------
function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
        console.error(gl.getShaderInfoLog(s));
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vertSrc));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fragSrc));
gl.linkProgram(prog);
gl.useProgram(prog);

// ---------- GEOMETRY ----------
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1,  -1,1,
    -1,1,   1,-1,   1,1
]), gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(prog, "pos");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// ---------- UNIFORMS ----------
const centerHiLoc = gl.getUniformLocation(prog, "centerHi");
const centerLoLoc = gl.getUniformLocation(prog, "centerLo");
const zoomLoc     = gl.getUniformLocation(prog, "zoom");
const resLoc      = gl.getUniformLocation(prog, "resolution");

// ---------- STATE ----------
let centerX = -0.5;
let centerY = 0.0;
let zoom = 1.0;

function split(x) {
    const hi = Math.fround(x);
    return [hi, x - hi];
}

// ---------- INPUT ----------
let dragging = false;
let lastX, lastY;

canvas.onmousedown = e => {
    dragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
};

canvas.onmouseup = () => dragging = false;

canvas.onmousemove = e => {
    if (!dragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;

    const scale = 1.0 / zoom;
    centerX -= dx * scale * 0.002;
    centerY += dy * scale * 0.002;
};

canvas.onwheel = e => {
    e.preventDefault();
    const z = Math.exp(-e.deltaY * 0.001);
    zoom *= z;
};

// ---------- RENDER LOOP ----------
function draw() {
    const [cxh, cxl] = split(centerX);
    const [cyh, cyl] = split(centerY);

    gl.uniform2f(centerHiLoc, cxh, cyh);
    gl.uniform2f(centerLoLoc, cxl, cyl);
    gl.uniform1f(zoomLoc, zoom);
    gl.uniform2f(resLoc, canvas.width, canvas.height);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Turbo Trackers — Arcade Drift Multiplayer</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body { margin:0; overflow:hidden; background:#111; height:100%; }
  canvas { display:block; background:#202225; width:100vw; height:100vh; }
  #hud {
    position:absolute; top:10px; left:50%; transform:translateX(-50%);
    display:flex; gap:16px; color:#fff; font-family:system-ui, sans-serif;
    font-size:14px; font-weight:700; z-index:10; flex-wrap:wrap; justify-content:center;
  }
  .bar { display:flex; align-items:center; gap:6px; }
  .bar .name { opacity:0.8; min-width:54px; text-align:right; }
  .bar .track { width:140px; height:12px; background:#3a3d41; border:1px solid #9aa0a6; border-radius:6px; overflow:hidden; }
  .bar .fill { height:100%; width:100%; background:linear-gradient(90deg, #33ff66, #aaff33); }

  #deadScreen {
    position:absolute; inset:0; display:none; z-index:20;
    background:rgba(0,0,0,0.72); color:#fff; font-family:system-ui, sans-serif;
    align-items:center; justify-content:center; flex-direction:column; gap:16px;
    text-align:center; padding:24px;
  }
  #deadScreen .title { font-size:28px; font-weight:800; letter-spacing:0.5px; }
  #deadScreen .sub { font-size:18px; opacity:0.9; }
</style>
</head>
<body>
<script>
// ===== Chat UI =====
const chatBtn = document.createElement("div");
chatBtn.id = "chatBtn";
chatBtn.style = `
  position:absolute; top:12px; right:12px;
  width:32px; height:28px; cursor:pointer; z-index:15;
  display:flex; flex-direction:column; justify-content:space-around;
  padding:4px; background:rgba(0,0,0,0.5); border-radius:4px;
`;
for(let i=0;i<3;i++){
  const line = document.createElement("div");
  line.style = "height:3px; background:#fff; border-radius:2px;";
  chatBtn.appendChild(line);
}
document.body.appendChild(chatBtn);

const chatSidebar = document.createElement("div");
chatSidebar.id = "chatSidebar";
chatSidebar.style = `
  position:absolute; top:0; right:-280px; width:280px; height:100%;
  background:#222; color:#fff; font-family:system-ui; padding:12px;
  transition:right 0.3s; overflow-y:auto; z-index:14;
`;
document.body.appendChild(chatSidebar);

const chatInput = document.createElement("input");
chatInput.placeholder = "Type message...";
chatInput.style = "width:100%; box-sizing:border-box; padding:6px; margin-top:6px;";
chatSidebar.appendChild(chatInput);

let chatOpen = false;
chatBtn.addEventListener("click", ()=>{
  chatOpen = !chatOpen;
  chatSidebar.style.right = chatOpen ? "0px" : "-280px";
  if(chatOpen) chatInput.focus();
});

// ===== Chat networking =====
const messages = [];
channel.subscribe("chat", msg => {
  const text = msg.data;
  messages.push(text);
  updateChatSidebar();
});

function updateChatSidebar(){
  chatSidebar.innerHTML = "";
  messages.slice(-50).forEach(m=>{
    const div = document.createElement("div");
    div.textContent = m;
    div.style.marginBottom="4px";
    chatSidebar.appendChild(div);
  });
  chatSidebar.appendChild(chatInput); // keep input at bottom
}

// Send message on Enter
chatInput.addEventListener("keydown", e=>{
  if(e.key === "Enter" && chatInput.value.trim()){
    const text = `${me.name}: ${chatInput.value.trim()}`;
    channel.publish("chat", text);
    chatInput.value = "";
  }
});
</script>
  
  <div id="hud"></div>
  <div id="deadScreen">
    <div class="title" id="killerText"></div>
    <div class="sub" id="respawnText"></div>
  </div>
  <canvas id="game" width="1180" height="713"></canvas>

  <script src="https://cdn.ably.io/lib/ably.min-1.js"></script>
  <script>
  // ===== Canvas =====
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
  addEventListener("resize", resize); resize();

  // ===== Assets =====
  const carMe = new Image(); carMe.src = "assets/red_car.svg";
  const carOther = new Image(); carOther.src = "assets/blue_car.svg";
  const CAR_W = 96, CAR_H = 47.6; // matches your SVG scale

  // ===== Networking (Ably) =====
  const API_KEY = "Nllp5A.3TYLaQ:G74XydAZRQIJ0-IwWsjhBj6HNcaeiYjdyWUc4zq1TiE";
  const ROOM = "racing-room";
  const ably = new Ably.Realtime(API_KEY);
  const channel = ably.channels.get(ROOM);

  // ===== Input =====
  const meKeys = {};
  const keyMap = {
    ArrowUp:"up", ArrowDown:"down", ArrowLeft:"left", ArrowRight:"right",
    w:"up", a:"left", s:"down", d:"right", Shift:"drift"
  };
  addEventListener("keydown", e => { if (keyMap[e.key]) meKeys[keyMap[e.key]] = true; });
  addEventListener("keyup",   e => { if (keyMap[e.key]) meKeys[keyMap[e.key]] = false; });

  // ===== Particles =====
  const particles = [];
  class Particle {
    constructor(x,y, size, life, vx, vy, color){
      this.x=x; this.y=y; this.size=size; this.life=life; this.vx=vx||0; this.vy=vy||0; this.color=color||"white"; this.maxLife=life;
    }
    update(){
      this.life--;
      this.x += this.vx; this.y += this.vy;
    }
    draw(){
      ctx.globalAlpha = Math.max(0, this.life / this.maxLife);
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
  function burst(x,y, count, baseSpeed, color, size=3, life=30){
    for(let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2;
      const s = baseSpeed*(0.4+0.6*Math.random());
      particles.push(new Particle(x,y, size*(0.8+Math.random()*0.6), life+Math.floor(Math.random()*10),
        Math.cos(a)*s, Math.sin(a)*s, color));
    }
  }

  // ===== World / Map =====
  const WORLD_W = 10000;
  const WORLD_H = 10000;

  // Example obstacles
  const obstacles = [
  {x:400, y:300, w:120, h:60},
  {x:900, y:600, w:200, h:40},
  {x:1600, y:1200, w:100, h:150}
  ];

  // ===== Player / Physics =====
  function rand(start, end){ return start + Math.random()*(end-start); }
  const ID = Math.random().toString(36).slice(2,7);

  function makePlayer(isMe){
    return {
      id: isMe ? ID : "?", name: isMe ? "You" : "P",
      x: rand(CAR_W, canvas.width-CAR_W), y: rand(CAR_H, canvas.height-CAR_H),
      angle: 0, // where the car points
      vx: 0, vy: 0, // actual velocity vector
      speedCapFwd: 10.0,
      speedCapBack: -3.0,
      accel: 0.25, // per 60fps frame
      brake: 0.18,
      baseTurn: 0.04,  // normal turning — calm
      driftTurn: 0.05, // extra turn when drifting
      gripLong: 0.985,  // forward grip
      gripLat: 0.80,    // lateral damping (normal driving)
      gripLatDrift: 0.95, // higher = less lateral damping -> more slide
      drag: 0.992,      // air drag
      drift: false,
      health: 100,
      dead: false,
      stunned: 0,
      respawnTimer: 0,
      killer: null,
      lastHitBy: null, // track last collider id
    };
  }

  const me = makePlayer(true);
  const remotes = {}; // id -> {state/history/ui}
  const HISTORY = 24, INTERP_DELAY = 120, SEND_MS = 50;

  // Interp helpers
  function pushHistory(o, snap){
    if(!o.history) o.history = [];
    o.history.push(snap);
    if(o.history.length > HISTORY) o.history.shift();
    o.lastSeen = performance.now();
  }
  function getInterpolatedState(history, now){
    if(!history || !history.length) return null;
    const rt = now - INTERP_DELAY;
    if(rt <= history[0].t) return history[0];
    for(let i=history.length-2;i>=0;i--){
      const a = history[i], b = history[i+1];
      if(a.t <= rt && rt <= b.t){
        const f = (rt - a.t) / Math.max(1, b.t - a.t);
        return {
          x: a.x + (b.x-a.x)*f,
          y: a.y + (b.y-a.y)*f,
          angle: a.angle + (b.angle-a.angle)*f,
          vx: a.vx + (b.vx-a.vx)*f,
          vy: a.vy + (b.vy-a.vy)*f,
          speed: a.speed + (b.speed-a.speed)*f,
          t: rt
        };
      }
    }
    return history[history.length-1];
  }

  // ===== HUD (dynamic) =====
  const hud = document.getElementById("hud");
  function rebuildHUD(){
    hud.innerHTML = "";
    const everyone = [me, ...Object.values(remotes).map(r=>r.state)];
    everyone.forEach((p, i)=>{
      const wrap = document.createElement("div");
      wrap.className = "bar";
      const name = document.createElement("div");
      name.className = "name";
      name.textContent = (p.id===me.id? "You" : p.id).slice(0,6);
      const track = document.createElement("div"); track.className = "track";
      const fill = document.createElement("div"); fill.className = "fill"; fill.id = "hp-"+p.id;
      track.appendChild(fill);
      wrap.appendChild(name); wrap.appendChild(track);
      hud.appendChild(wrap);
    });
  }

  function updateHUDValues(){
    const setFill = (id, hp)=>{
      const el = document.getElementById("hp-"+id);
      if(el) el.style.width = Math.max(0, Math.min(100, hp)) + "%";
    };
    setFill(me.id, me.health);
    for(const id in remotes) setFill(id, remotes[id].state.health);
  }

  // ===== Dead overlay =====
  const deadScreen = document.getElementById("deadScreen");
  const killerText = document.getElementById("killerText");
  const respawnText = document.getElementById("respawnText");

  function showDeadOverlay(show){
    deadScreen.style.display = show ? "flex" : "none";
  }

  // ===== Drawing =====
  function drawCar(x, y, angle, slip, image){
    // slip: lateral slip amount -> slight yaw for visuals
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle + slip * 0.1); // small visual yaw with slip
    ctx.drawImage(image, -CAR_W/2, -CAR_H/2, CAR_W, CAR_H);
    ctx.restore();
  }

  // ===== Physics Update (local player) =====
  function updateLocal(dt, now){
    const fwdX = Math.cos(me.angle), fwdY = Math.sin(me.angle);
    const sideX = -fwdY, sideY = fwdX;

    if(!me.dead){
        if(me.stunned > 0) me.stunned -= dt*60;
        else {
            if(document.activeElement !== chatInput){ // only allow movement when chat not focused
                if(meKeys.up){
                    me.vx += fwdX * me.accel * 60 * dt;
                    me.vy += fwdY * me.accel * 60 * dt;
                    if(Math.random()<0.4) particles.push(new Particle(
                        me.x - fwdX*20 + (Math.random()-0.5)*6,
                        me.y - fwdY*20 + (Math.random()-0.5)*6,
                        2, 16, (-fwdX+(Math.random()-0.5))*0.6, (-fwdY+(Math.random()-0.5))*0.6, "rgba(220,220,220,1)"
                    ));
                }
                if(meKeys.down){
                    me.vx -= fwdX * me.brake * 60 * dt * 0.7;
                    me.vy -= fwdY * me.brake * 60 * dt * 0.7;
                }
                const speed = Math.hypot(me.vx, me.vy);
                const turnBase = me.baseTurn * (0.6 + 0.4*Math.min(1, speed/6));
                const drifting = !!meKeys.drift && speed>1.2;
                me.drift = drifting;
                const turn = drifting ? (turnBase + me.driftTurn) : turnBase;
                if(meKeys.left) me.angle -= turn*60*dt;
                if(meKeys.right) me.angle += turn*60*dt;
                if(drifting){ me.vx += sideX*0.06*60*dt; me.vy += sideY*0.06*60*dt; }
            }
        }
    }

    // Decompose
    const vLong = me.vx*fwdX + me.vy*fwdY;
    const vLat  = me.vx*sideX + me.vy*sideY;

    const cappedLong = Math.max(me.speedCapBack, Math.min(me.speedCapFwd, vLong));
    const latGrip = me.drift ? me.gripLatDrift : me.gripLat;
    const newVLong = cappedLong*me.gripLong;
    const newVLat  = vLat*latGrip;
    me.vx = fwdX*newVLong + sideX*newVLat;
    me.vy = fwdY*newVLong + sideY*newVLat;
    me.vx *= me.drag; me.vy *= me.drag;

    me.x += me.vx*60*dt;
    me.y += me.vy*60*dt;

    // BORDER CHECK
    if(me.x < 0){ me.health=0; me.x=0; }
    if(me.y < 0){ me.health=0; me.y=0; }
    if(me.x > WORLD_W){ me.health=0; me.x=WORLD_W; }
    if(me.y > WORLD_H){ me.health=0; me.y=WORLD_H; }

    // Drift sparks
    const slipMag = Math.abs(vLat);
    if(me.drift && slipMag>0.6 && Math.random()<0.5){
        const backX = me.x - fwdX*26, backY = me.y - fwdY*26;
        burst(backX, backY, 1, 1.4, "orange", 2, 14);
    }

    return slipMag;
}

  // ===== Collisions =====
  function carRadius(){ return Math.max(CAR_W, CAR_H)*0.45; }
  function collideLocalWithRemote(remoteState){
    if(me.dead || remoteState.dead) return;

    const dx = remoteState.x - me.x, dy = remoteState.y - me.y;
    const dist = Math.hypot(dx, dy);
    const r = carRadius()*0.9 + carRadius()*0.9;
    if(dist > r) return;

    // Normal from me -> them
    const nX = dx / (dist || 1), nY = dy / (dist || 1);

    // Determine faces
    const mF = [Math.cos(me.angle), Math.sin(me.angle)];
    const oF = [Math.cos(remoteState.angle), Math.sin(remoteState.angle)];

    // Are we facing each other?
    const facing = mF[0]*oF[0] + mF[1]*oF[1]; // dot of forwards
    const meFacingThem = mF[0]*nX + mF[1]*nY;   // >0 means my front toward them
    const themFacingMe = -(oF[0]*nX + oF[1]*nY); // >0 means their front toward me

    const meSpeed = Math.hypot(me.vx, me.vy);
    const themSpeed = Math.hypot(remoteState.vx||0, remoteState.vy||0);
    const combined = meSpeed + themSpeed;

    // Impact category
    let headOn = (meFacingThem > 0.6 && themFacingMe > 0.6 && facing < -0.2);
    // Side/back resolution for damage target
    const hitTheirSide = Math.abs(oF[0]*nX + oF[1]*nY) < 0.35; // normal near their side
    const hitTheirBack = (oF[0]*nX + oF[1]*nY) < -0.6;

    // Damage numbers
    let dmgMe = 0, dmgThem = 0;
    if(headOn){
      const scale = Math.max(0, combined*2.4); // scale with combined speed
      if(combined > 11) { dmgMe = 999; dmgThem = 999; } // instant KO
      else { dmgMe = Math.floor(scale); dmgThem = Math.floor(scale); }
    } else {
      // I hit them with my front?
      if(meFacingThem > 0.4){
        if(hitTheirSide) dmgThem = Math.floor(meSpeed * 14); // side = more
        else if(hitTheirBack) dmgThem = Math.floor(meSpeed * 8); // back = less
        else dmgThem = Math.floor(meSpeed * 10); // front-ish
      }
      // They hit me with their front?
      if(themFacingMe > 0.4){
        if(Math.abs(oF[0]*nX + oF[1]*nY) < 0.35) dmgMe = Math.floor(themSpeed * 14);
        else if((oF[0]*nX + oF[1]*nY) < -0.6)    dmgMe = Math.floor(themSpeed * 8);
        else dmgMe = Math.floor(themSpeed * 10);
      }
    }

    // Apply damage (local prediction — authoritative for me)
    if(dmgThem > 0){ /* we only predict their health visually */
      const o = remotes[remoteState.id];
      if(o){ o.state.health = Math.max(0, o.state.health - dmgThem); o.state.killer = me.id; }
    }
    if(dmgMe > 0){
      me.health = Math.max(0, me.health - dmgMe);
      me.killer = remoteState.id;
    }

    // Knockback impulse along normal (separate from damage)
    const impulse = Math.min(14, 6 + combined*0.7);
    me.vx -= nX * impulse; me.vy -= nY * impulse;
    // fake remote knockback locally for visuals
    if(remotes[remoteState.id]){
      const rs = remotes[remoteState.id].state;
      rs.vx += nX * impulse; rs.vy += nY * impulse;
    }

    // Stun
    me.stunned = 12;

    // Crash particles
    burst(me.x + nX*20, me.y + nY*20, 14, 4.2, "orange", 3, 30);
    burst(me.x + nX*20, me.y + nY*20, 6, 2.4, "yellow", 2, 20);
  }

  // ===== Respawn =====
  function respawn(p){
    p.x = rand(CAR_W, canvas.width-CAR_W);
    p.y = rand(CAR_H, canvas.height-CAR_H);
    p.vx = p.vy = 0;
    p.angle = rand(0, Math.PI*2);
    p.health = 100;
    p.dead = false;
    p.stunned = 0;
    p.killer = null;
    burst(p.x, p.y, 16, 3.5, "lime", 4, 36);
  }

  // ===== Networking receive =====
  channel.subscribe("player-state", (msg) => {
    const d = msg.data || {};
    if(!d.id || d.id === me.id) return;

    let obj = remotes[d.id];
    if(!obj){
      obj = remotes[d.id] = {
        state: makePlayer(false), history: [], lastSeen: performance.now()
      };
      obj.state.id = d.id;
      obj.state.name = d.id;
      rebuildHUD();
    }
    obj.state.health = d.health;
    obj.state.dead = d.dead;
    obj.state.respawnTimer = d.respawnTimer || 0;
    obj.state.killer = d.killer || null;

    pushHistory(obj, {
      x: d.x, y: d.y, angle: d.angle, vx: d.vx, vy: d.vy,
      speed: d.speed, t: performance.now()
    });
  });

  function getCameraOffset() {
      let camX = me.x - canvas.width/2;
      let camY = me.y - canvas.height/2;
      camX = Math.max(0, Math.min(camX, WORLD_W - canvas.width));
      camY = Math.max(0, Math.min(camY, WORLD_H - canvas.height));
      return {camX, camY};
  }

    
  // ===== Draw Loop =====
  let lastSent = 0, last = performance.now();
  rebuildHUD();

function loop(now){
    const dt = Math.min(0.033,(now-last)/1000); last=now;

    // LOCAL
    let slip = 0;
    if(!me.dead) slip = updateLocal(dt, now);
    else {
        me.respawnTimer -= dt;
        if(me.respawnTimer<=0) respawn(me);
    }

    // REMOTES
    for(const id in remotes){
        const o = remotes[id];
        if(now-o.lastSeen>5000){ delete remotes[id]; rebuildHUD(); continue; }
        const s = getInterpolatedState(o.history, now);
        if(s){ o.state.x=s.x; o.state.y=s.y; o.state.angle=s.angle; o.state.vx=s.vx; o.state.vy=s.vy; }
        if(o.state.dead){ o.state.respawnTimer-=dt; if(o.state.respawnTimer<=0) respawn(o.state); }
    }

    // COLLISIONS
    for(const id in remotes){
        const s = remotes[id].state;
        if(!s.dead) collideLocalWithRemote(s);
    }

    // DEATH
    if(me.health<=0 && !me.dead){
        me.dead = true; me.vx=me.vy=0; me.respawnTimer=5;
        const killerName = me.killer?me.killer.slice(0,6):"Unknown";
        killerText.textContent = `You were killed by ${killerName}`;
        burst(me.x, me.y,28,5.0,"red",4,44);
    }

    // DRAW
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const {camX,camY} = getCameraOffset();
    ctx.save(); ctx.translate(-camX,-camY);

    // background
    ctx.fillStyle="#202225";
    ctx.fillRect(0,0,WORLD_W,WORLD_H);

    // MAP BORDER
    ctx.strokeStyle="red"; ctx.lineWidth=2;
    ctx.strokeRect(0,0,WORLD_W,WORLD_H);

    // obstacles
    ctx.fillStyle="#555";
    obstacles.forEach(o=>ctx.fillRect(o.x,o.y,o.w,o.h));

    // particles
    for(let i=particles.length-1;i>=0;i--){ particles[i].update(); particles[i].draw(); if(particles[i].life<=0) particles.splice(i,1); }

    // cars
    if(!me.dead){ const fX=Math.cos(me.angle), fY=Math.sin(me.angle), sX=-fY, sY=fX; const vLat=me.vx*sX+me.vy*sY; drawCar(me.x,me.y,me.angle,vLat,carMe);}
    for(const id in remotes){ const r=remotes[id].state; if(r.dead) continue; const fX=Math.cos(r.angle), fY=Math.sin(r.angle), sX=-fY, sY=fX; const vLat=(r.vx||0)*sX+(r.vy||0)*sY; drawCar(r.x,r.y,r.angle,vLat,carOther); }

    ctx.restore();

    // radar
    (function drawRadar(){
        const radarRadius=60, centerX=canvas.width-80, centerY=80;
        ctx.save();
        ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.beginPath();
        ctx.arc(centerX,centerY,radarRadius,0,Math.PI*2); ctx.fill();
        ctx.fillStyle="lime"; ctx.beginPath(); ctx.arc(centerX,centerY,4,0,Math.PI*2); ctx.fill();
        for(const id in remotes){
            const r=remotes[id].state; if(r.dead) continue;
            const dx=r.x-me.x, dy=r.y-me.y; const dist=Math.hypot(dx,dy);
            const maxRadarDist=300; if(dist<=maxRadarDist){
                const rx=centerX+dx/maxRadarDist*radarRadius;
                const ry=centerY+dy/maxRadarDist*radarRadius;
                ctx.fillStyle="red"; ctx.beginPath(); ctx.arc(rx,ry,4,0,Math.PI*2); ctx.fill();
            }
        }
        ctx.restore();
    })();

    requestAnimationFrame(loop);
}
  requestAnimationFrame(loop);
  </script>
</body>
</html>

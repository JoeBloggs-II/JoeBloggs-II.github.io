<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Mandelbrot GPU Explorer</title>
<style>
html, body {
    margin: 0;
    height: 100%;
    background: black;
    overflow: hidden;
}

#container {
    position: fixed;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
}

canvas {
    background: black;
    image-rendering: crisp-edges;
    touch-action: none;
}
</style>
</head>
<body>
<div id="container">
    <canvas id="canvas"></canvas>
</div>

<script>
const canvas = document.getElementById("canvas");
const gl = canvas.getContext("webgl");

if (!gl) alert("WebGL not supported");

let centerX = -0.5;
let centerY = 0.0;
let scale = 3.0;

function resize() {
    const size = Math.min(window.innerWidth, window.innerHeight);
    canvas.width = size * devicePixelRatio;
    canvas.height = size * devicePixelRatio;
    canvas.style.width = size + "px";
    canvas.style.height = size + "px";
    gl.viewport(0, 0, canvas.width, canvas.height);
    render();
}

window.addEventListener("resize", resize);
resize();

/* ===== Shaders ===== */

const vs = `
attribute vec2 pos;
void main() {
    gl_Position = vec4(pos,0,1);
}
`;

const fs = `
precision highp float;

uniform vec2 center;
uniform float scale;
uniform vec2 resolution;

int mandelbrot(vec2 c) {
    vec2 z = vec2(0.0);
    int i;
    for (i = 0; i < 1000; i++) {
        if (dot(z,z) > 4.0) break;
        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
    }
    return i;
}

void main() {
    vec2 uv = (gl_FragCoord.xy / resolution - 0.5);
    uv.x *= resolution.x / resolution.y;

    vec2 c = center + uv * scale;

    int it = mandelbrot(c);

    float t = float(it) / 1000.0;

    vec3 col = vec3(
        0.5 + 0.5*cos(6.2831*(t+0.0)),
        0.5 + 0.5*cos(6.2831*(t+0.33)),
        0.5 + 0.5*cos(6.2831*(t+0.67))
    );

    if (it == 1000) col = vec3(0.0);

    gl_FragColor = vec4(col,1.0);
}
`;

function compile(type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
gl.useProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1,
    -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(prog, "pos");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

const centerLoc = gl.getUniformLocation(prog, "center");
const scaleLoc = gl.getUniformLocation(prog, "scale");
const resLoc = gl.getUniformLocation(prog, "resolution");

function render() {
    gl.uniform2f(centerLoc, centerX, centerY);
    gl.uniform1f(scaleLoc, scale);
    gl.uniform2f(resLoc, canvas.width, canvas.height);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

/* ===== Zoom logic ===== */

function screenToComplex(px, py) {
    const rect = canvas.getBoundingClientRect();

    const x = (px - rect.left) / rect.width;
    const y = (py - rect.top) / rect.height;

    const aspect = canvas.width / canvas.height;

    const cx = centerX + (x - 0.5) * scale * aspect;
    const cy = centerY + (y - 0.5) * scale;

    return { cx, cy };
}

function zoomAt(px, py, factor) {
    const before = screenToComplex(px, py);

    scale *= factor;

    const after = screenToComplex(px, py);

    centerX += before.cx - after.cx;
    centerY += before.cy - after.cy;

    render();
}

/* ===== Mouse ===== */

canvas.addEventListener("wheel", e => {
    e.preventDefault();
    const f = e.deltaY < 0 ? 0.85 : 1.15;
    zoomAt(e.clientX, e.clientY, f);
}, { passive: false });

/* ===== Touch ===== */

let lastDist = null;

canvas.addEventListener("touchmove", e => {
    if (e.touches.length !== 2) return;
    e.preventDefault();

    const t1 = e.touches[0];
    const t2 = e.touches[1];

    const dx = t1.clientX - t2.clientX;
    const dy = t1.clientY - t2.clientY;
    const dist = Math.hypot(dx, dy);

    const midX = (t1.clientX + t2.clientX) / 2;
    const midY = (t1.clientY + t2.clientY) / 2;

    if (lastDist !== null) {
        const factor = lastDist / dist;
        zoomAt(midX, midY, factor);
    }

    lastDist = dist;
}, { passive: false });

canvas.addEventListener("touchend", () => lastDist = null);

render();
</script>
</body>
</html>

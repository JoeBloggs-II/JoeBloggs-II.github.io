<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Turbo Trackers — Arcade Drift Multiplayer</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  html, body { margin:0; overflow:hidden; background:#111; height:100%; }
  /* prevent accidental scrollbars caused by focus outlines etc. */
  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  canvas { display:block; background:#202225; width:100vw; height:100vh; }
  #hud {
    position:absolute; top:10px; left:50%; transform:translateX(-50%);
    display:flex; gap:16px; color:#fff; font-family:system-ui, sans-serif;
    font-size:14px; font-weight:700; z-index:10; flex-wrap:wrap; justify-content:center;
  }
  .bar { display:flex; align-items:center; gap:6px; }
  .bar .name { opacity:0.8; min-width:54px; text-align:right; }
  .bar .track { width:140px; height:12px; background:#3a3d41; border:1px solid #9aa0a6; border-radius:6px; overflow:hidden; }
  .bar .fill { height:100%; width:100%; background:linear-gradient(90deg, #33ff66, #aaff33); }

  #deadScreen { position:absolute; inset:0; display:none; z-index:20;
    background:rgba(0,0,0,0.72); color:#fff; font-family:system-ui, sans-serif;
    align-items:center; justify-content:center; flex-direction:column; gap:16px;
    text-align:center; padding:24px;
  }
  #deadScreen .title { font-size:28px; font-weight:800; letter-spacing:0.5px; }
  #deadScreen .sub { font-size:18px; opacity:0.9; }

  /* small OOB timer display */
  #oobWarn {
    position: absolute; left: 50%; transform: translateX(-50%); top: 70px;
    z-index: 21; color: #ffcc00; font-family: system-ui; font-weight:700;
    text-shadow: 0 2px 6px rgba(0,0,0,0.6);
  }

  /* chat button focus outline improvement */
  #chatBtn:focus { outline: none; box-shadow:0 0 0 3px rgba(255,255,255,0.06) }
</style>
</head>
<body>

<!-- HUD + Dead overlay -->
<div id="hud"></div>
<div id="deadScreen">
  <div class="title" id="killerText"></div>
  <div class="sub" id="respawnText"></div>
</div>
<div id="oobWarn" style="display:none;"></div>

<!-- Game canvas -->
<canvas id="game"></canvas>

<!-- Ably -->
<script src="https://cdn.ably.io/lib/ably.min-1.js"></script>

<script>
/* ============================================================
   UX: username prompt saved to cookie (so we only ask once)
   ============================================================ */
function cookieGet(name){
  const m = document.cookie.match(new RegExp('(^| )'+name+'=([^;]+)'));
  return m ? decodeURIComponent(m[2]) : null;
}
function cookieSet(name, value, days=365){
  const exp = new Date(); exp.setTime(exp.getTime() + days*24*60*60*1000);
  document.cookie = `${name}=${encodeURIComponent(value)}; path=/; expires=${exp.toUTCString()}`;
}
let savedName = cookieGet('tt_name');
if(!savedName){
  // prompt while being polite
  const n = prompt("Pick a username for Turbo Trackers (saved locally):", "Player"+Math.floor(Math.random()*900+100));
  savedName = (n && n.trim()) ? n.trim() : "Player"+Math.floor(Math.random()*900+100);
  cookieSet('tt_name', savedName, 3650);
}

/* =========================
   CHAT UI (button + sidebar)
   ========================= */
const chatBtn = document.createElement("button");
chatBtn.id = "chatBtn";
chatBtn.title = "Open chat";
chatBtn.innerHTML = '&#9776;'; // simple hamburger glyph
chatBtn.style = `
  position:absolute; top:12px; right:12px;
  width:36px; height:34px; cursor:pointer; z-index:15;
  display:flex; align-items:center; justify-content:center;
  padding:4px; background:rgba(0,0,0,0.55); border-radius:6px;
  color:white; font-size:18px; border:0;
  box-shadow:0 2px 6px rgba(0,0,0,0.4);
`;
document.body.appendChild(chatBtn);

const chatSidebar = document.createElement("div");
chatSidebar.id = "chatSidebar";
chatSidebar.style = `
  position:absolute; top:0; right:-320px; width:320px; height:100%;
  background:#1d1f22; color:#fff; font-family:system-ui;
  box-shadow:-8px 0 18px rgba(0,0,0,0.45);
  display:flex; flex-direction:column; padding:12px; transition:right 0.22s; z-index:14;
`;
document.body.appendChild(chatSidebar);

const chatLog = document.createElement("div");
chatLog.style = "flex:1 1 auto; overflow-y:auto; font-size:13px; line-height:1.35; padding-right:6px;";
chatSidebar.appendChild(chatLog);

const chatInput = document.createElement("input");
chatInput.placeholder = "Type message...";
chatInput.style = "flex:0 0 auto; width:100%; box-sizing:border-box; padding:8px 10px; border-radius:6px; border:none; outline:none; background:#2a2d31; color:#fff;";
chatSidebar.appendChild(chatInput);

let chatOpen = false;
chatBtn.addEventListener("click", () => {
  chatOpen = !chatOpen;
  chatSidebar.style.right = chatOpen ? "0px" : "-320px";
  if (chatOpen) setTimeout(()=> chatInput.focus(), 50);
});

/* ===========
   CANVAS & ASSETS
   =========== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener("resize", resize); resize();

const carMe = new Image(); carMe.src = "assets/red_car.svg";
const carOther = new Image(); carOther.src = "assets/blue_car.svg";
const CAR_W = 96, CAR_H = 47.6;

/* ===========
   NETWORKING
   =========== */
const API_KEY = "Nllp5A.3TYLaQ:G74XydAZRQIJ0-IwWsjhBj6HNcaeiYjdyWUc4zq1TiE";
const ROOM = "racing-room";
const ably = new Ably.Realtime(API_KEY);
const channel = ably.channels.get(ROOM);

/* ==============
   CHAT NETWORKING
   ============== */
const messages = [];
function renderChat() {
  chatLog.innerHTML = "";
  messages.slice(-200).forEach(m => {
    const row = document.createElement("div");
    row.textContent = m;
    row.style.margin = "4px 0";
    chatLog.appendChild(row);
  });
  chatLog.scrollTop = chatLog.scrollHeight;
}
channel.subscribe("chat", (msg) => {
  const d = msg.data;
  if (typeof d === "string") messages.push(d);
  else if (d && d.id && d.text) messages.push(`${d.name || d.id.slice(0,6)}: ${d.text}`);
  renderChat();
});
chatInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && chatInput.value.trim()){
    const text = chatInput.value.trim();
    channel.publish("chat", { id: me.id, name: me.name, text });
    chatInput.value = "";
  }
});

/* =========
   WORLD
   ========= */
const WORLD_W = 5000;
const WORLD_H = 5000;

/* ==========
   PARTICLES
   ========== */
const particles = [];
class Particle {
  constructor(x,y,size,life,vx,vy,color){
    this.x=x; this.y=y; this.size=size; this.life=life; this.vx=vx||0; this.vy=vy||0; this.color=color||"white"; this.maxLife=life;
  }
  update(){ this.life--; this.x+=this.vx; this.y+=this.vy; }
  draw(){ ctx.globalAlpha=Math.max(0,this.life/this.maxLife); ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.size,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
}
function burst(x,y,count,baseSpeed,color,size=3,life=30){
  for(let i=0;i<count;i++){
    const a=Math.random()*Math.PI*2;
    const s=baseSpeed*(0.4+0.6*Math.random());
    particles.push(new Particle(x,y,size*(0.8+Math.random()*0.6),life+Math.floor(Math.random()*10),Math.cos(a)*s,Math.sin(a)*s,color));
  }
}

/* =========
   PLAYERS
   ========= */
function rand(a,b){ return a + Math.random()*(b-a); }
const ID = Math.random().toString(36).slice(2,7);

function makePlayer(isMe){
  return {
    id: isMe ? ID : "?",
    name: isMe ? savedName || ("You"+Math.floor(Math.random()*900)) : "P",
    x: rand(CAR_W, WORLD_W - CAR_W),
    y: rand(CAR_H, WORLD_H - CAR_H),
    angle: 0,
    vx: 0, vy: 0,
    speedCapFwd: 10.0,
    speedCapBack: -3.0,
    accel: 0.25,
    brake: 0.18,
    baseTurn: 0.04,
    driftTurn: 0.05,
    gripLong: 0.985,
    gripLat: 0.80,
    gripLatDrift: 0.95,
    drag: 0.992,
    drift: false,
    health: 100,
    dead: false,
    stunned: 0,
    respawnTimer: 0,
    oobTimer: 0,      // out-of-bounds timer
    killer: null,
    lastHitBy: null
  };
}
const me = makePlayer(true);
const remotes = {};   // id -> { state, history, lastSeen }
const HISTORY = 24, INTERP_DELAY = 120, SEND_MS = 50;

/* ========
   INPUT
   ======== */
const meKeys = {};
const keyMap = {
  ArrowUp:"up", ArrowDown:"down", ArrowLeft:"left", ArrowRight:"right",
  w:"up", a:"left", s:"down", d:"right", Shift:"drift"
};
addEventListener("keydown", e => {
  // prevent arrows / space from scrolling the page (when not typing in chat)
  const block = ["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "];
  if (block.includes(e.key) && document.activeElement !== chatInput) e.preventDefault();
  if (keyMap[e.key]) meKeys[keyMap[e.key]] = true;
});
addEventListener("keyup",   e => { if (keyMap[e.key]) meKeys[keyMap[e.key]] = false; });

/* =========================
   INTERPOLATION HELPERS
   ========================= */
function pushHistory(obj, snap){
  if (!obj.history) obj.history = [];
  obj.history.push(snap);
  if (obj.history.length > HISTORY) obj.history.shift();
  obj.lastSeen = performance.now();
}
function getInterpolatedState(history, now){
  if (!history || !history.length) return null;
  const rt = now - INTERP_DELAY;
  if (rt <= history[0].t) return history[0];
  for (let i = history.length - 2; i >= 0; i--){
    const a = history[i], b = history[i+1];
    if (a.t <= rt && rt <= b.t){
      const f = (rt - a.t) / Math.max(1, b.t - a.t);
      return {
        x: a.x + (b.x-a.x)*f,
        y: a.y + (b.y-a.y)*f,
        angle: a.angle + (b.angle-a.angle)*f,
        vx: a.vx + (b.vx-a.vx)*f,
        vy: a.vy + (b.vy-a.vy)*f,
        speed: a.speed + (b.speed-a.speed)*f,
        t: rt
      };
    }
  }
  return history[history.length-1];
}

/* =====
   HUD
   ===== */
const hud = document.getElementById("hud");
function rebuildHUD(){
  hud.innerHTML = "";
  const everyone = [me, ...Object.values(remotes).map(r=>r.state)];
  everyone.forEach(p=>{
    const wrap = document.createElement("div"); wrap.className = "bar";
    const name = document.createElement("div"); name.className = "name";
    name.textContent = (p.id===me.id? "You" : (p.name || p.id)).slice(0,10);
    const track = document.createElement("div"); track.className = "track";
    const fill = document.createElement("div"); fill.className = "fill"; fill.id = "hp-"+p.id;
    track.appendChild(fill);
    wrap.appendChild(name); wrap.appendChild(track);
    hud.appendChild(wrap);
  });
}
function updateHUDValues(){
  const setFill = (id, hp) => { const el = document.getElementById("hp-"+id); if (el) el.style.width = Math.max(0, Math.min(100, hp)) + "%"; };
  setFill(me.id, me.health);
  for (const id in remotes) setFill(id, remotes[id].state.health);
}
rebuildHUD();

/* =================
   DEAD OVERLAY
   ================= */
const deadScreen = document.getElementById("deadScreen");
const killerText = document.getElementById("killerText");
const respawnText = document.getElementById("respawnText");
function showDeadOverlay(show){ deadScreen.style.display = show ? "flex" : "none"; }

/* ==========================
   CAMERA / BORDER / RADAR
   ========================== */
function getCameraOffset(){
  let camX = me.x - canvas.width/2;
  let camY = me.y - canvas.height/2;
  camX = Math.max(0, Math.min(camX, WORLD_W - canvas.width));
  camY = Math.max(0, Math.min(camY, WORLD_H - canvas.height));
  return {camX, camY};
}
function drawBorder(){
  ctx.save();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "red";
  ctx.strokeRect(1,1, WORLD_W-2, WORLD_H-2);
  ctx.restore();
}
function checkBorderOOB(p, dt){
  // if out of bounds, start/decrement timer; if inside, reset
  const outside = (p.x < 0 || p.x > WORLD_W || p.y < 0 || p.y > WORLD_H);
  if (outside){
    if (!p.oobTimer || p.oobTimer <= 0) p.oobTimer = 6.0; // 6 seconds to get back
    else p.oobTimer -= dt;
    if (p.oobTimer <= 0){
      // die
      p.health = 0; p.dead = true; p.respawnTimer = 5;
      burst(p.x, p.y, 28, 5, "red", 4, 44);
    }
  } else {
    p.oobTimer = 0;
  }
}
function drawRadar(){
  const radarRadius = 60;
  const centerX = canvas.width - 80;
  const centerY = 80;
  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.beginPath(); ctx.arc(centerX, centerY, radarRadius, 0, Math.PI*2); ctx.fill();
  // you
  ctx.fillStyle = "lime"; ctx.beginPath(); ctx.arc(centerX, centerY, 4, 0, Math.PI*2); ctx.fill();
  // others (nearby)
  for(const id in remotes){
    const r = remotes[id].state;
    if (r.dead) continue;
    const dx = r.x - me.x, dy = r.y - me.y;
    const dist = Math.hypot(dx, dy);
    const maxRadarDist = 600; // shows further
    if (dist <= maxRadarDist){
      const rx = centerX + (dx / maxRadarDist) * radarRadius;
      const ry = centerY + (dy / maxRadarDist) * radarRadius;
      ctx.fillStyle = "red";
      ctx.beginPath(); ctx.arc(rx, ry, 4, 0, Math.PI*2); ctx.fill();
    }
  }
  ctx.restore();
}

/* =======================
   DRAWING / NAME TAGS
   ======================= */
function drawCar(x, y, angle, slip, image){
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle + slip * 0.1);
  ctx.drawImage(image, -CAR_W/2, -CAR_H/2, CAR_W, CAR_H);
  ctx.restore();
}
function drawNameTag(x, y, name, camX, camY){
  // draw above the car in screen space
  const sx = x - camX;
  const sy = y - camY - CAR_H/2 - 10;
  ctx.save();
  ctx.font = "14px system-ui";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  const w = ctx.measureText(name).width + 12;
  ctx.fillRect(sx - w/2, sy - 18, w, 20);
  ctx.fillStyle = "white";
  ctx.fillText(name, sx, sy - 4);
  ctx.restore();
}

/* ============================
   LOCAL PHYSICS / MOVEMENT
   (tiny tweak: movement disabled while typing in chat)
   ============================ */
function updateLocal(dt){
  const fwdX = Math.cos(me.angle), fwdY = Math.sin(me.angle);
  const sideX = -fwdY, sideY = fwdX;

  if (!me.dead){
    if (me.stunned > 0) me.stunned -= dt*60;
    else {
      // don't process movement keys if typing in chat
      const typing = (document.activeElement === chatInput);
      if (!typing){
        if (meKeys.up){ me.vx += fwdX * me.accel * 60 * dt; me.vy += fwdY * me.accel * 60 * dt; }
        if (meKeys.down){ me.vx -= fwdX * me.brake * 60 * dt * 0.7; me.vy -= fwdY * me.brake * 60 * dt * 0.7; }
        const speed = Math.hypot(me.vx, me.vy);
        const turnBase = me.baseTurn * (0.6 + 0.4*Math.min(1, speed/6));
        const drifting = !!meKeys.drift && speed > 1.2;
        me.drift = drifting;
        const turn = drifting ? (turnBase + me.driftTurn) : turnBase;
        if (meKeys.left)  me.angle -= turn * 60 * dt;
        if (meKeys.right) me.angle += turn * 60 * dt;
        if (drifting){ me.vx += sideX * 0.06 * 60 * dt; me.vy += sideY * 0.06 * 60 * dt; }
      }
    }
  }

  // velocity space
  const vLong = me.vx * fwdX + me.vy * fwdY;
  const vLat  = me.vx * sideX + me.vy * sideY;
  const cappedLong = Math.max(me.speedCapBack, Math.min(me.speedCapFwd, vLong));
  const latGrip = me.drift ? me.gripLatDrift : me.gripLat;
  const newVLong = cappedLong * me.gripLong;
  const newVLat  = vLat * latGrip;
  me.vx = fwdX * newVLong + sideX * newVLat;
  me.vy = fwdY * newVLong + sideY * newVLat;
  me.vx *= me.drag; me.vy *= me.drag;

  // move
  me.x += me.vx * 60 * dt;
  me.y += me.vy * 60 * dt;

  // tiny exhaust while moving
  if (!me.dead && Math.hypot(me.vx,me.vy) > 0.5 && Math.random() < 0.25){
    particles.push(new Particle(
      me.x - fwdX*20 + (Math.random()-0.5)*6,
      me.y - fwdY*20 + (Math.random()-0.5)*6,
      2, 16, (-fwdX + (Math.random()-0.5))*0.6, (-fwdY + (Math.random()-0.5))*0.6, "rgba(220,220,220,1)"
    ));
  }

  // drift sparks
  const slipMag = Math.abs(vLat);
  if (me.drift && slipMag > 0.6 && Math.random() < 0.5){
    const backX = me.x - fwdX * 26, backY = me.y - fwdY * 26;
    burst(backX, backY, 1, 1.4, "orange", 2, 14);
  }

  // out-of-bounds handling: starts timer rather than killing instantly
  checkBorderOOB(me, dt);

  return slipMag;
}

/* ==================
   PLAYER COLLISIONS
   ================== */
function carRadius(){ return Math.max(CAR_W, CAR_H)*0.45; }
function collideLocalWithRemote(remoteState){
  if (me.dead || remoteState.dead) return;

  const dx = remoteState.x - me.x, dy = remoteState.y - me.y;
  const dist = Math.hypot(dx, dy);
  const r = carRadius()*0.9 + carRadius()*0.9;
  if (dist > r) return;

  const meSpeed = Math.hypot(me.vx, me.vy);
  const themSpeed = Math.hypot(remoteState.vx||0, remoteState.vy||0);
  const combined = meSpeed + themSpeed;

  if (combined > 8) {
    // high speed => both explode (local prediction)
    if (!me.dead){
      me.health = 0; me.dead = true; me.respawnTimer = 5;
      me.killer = remoteState.id || remoteState.name || "unknown";
      burst(me.x, me.y, 28, 5, "red", 4, 44);
    }
    // show remote as dead visually (we set their state locally for visuals)
    if (remotes[remoteState.id]){
      remotes[remoteState.id].state.health = 0;
      remotes[remoteState.id].state.dead = true;
      remotes[remoteState.id].state.respawnTimer = 5;
      burst(remoteState.x, remoteState.y, 28, 5, "red", 4, 44);
    }
  } else {
    // low speed => stop both quickly
    me.vx *= 0.1; me.vy *= 0.1;
    if (remotes[remoteState.id]) {
      remotes[remoteState.id].state.vx *= 0.1;
      remotes[remoteState.id].state.vy *= 0.1;
    }
    burst((me.x+remoteState.x)/2, (me.y+remoteState.y)/2, 6, 2.5, "yellow", 2, 18);
  }
}

/* ===============
   RESPAWN FLOW
   =============== */
function respawn(p){
  p.x = rand(CAR_W, WORLD_W - CAR_W);
  p.y = rand(CAR_H, WORLD_H - CAR_H);
  p.vx = p.vy = 0;
  p.angle = rand(0, Math.PI*2);
  p.health = 100;
  p.dead = false;
  p.stunned = 0;
  p.killer = null;
  p.oobTimer = 0;
  burst(p.x, p.y, 16, 3.5, "lime", 4, 36);
}

/* ==========================
   NETWORK RECEIVE (players)
   ========================== */
channel.subscribe("player-state", (msg) => {
  const d = msg.data || {};
  if (!d.id || d.id === me.id) return;

  let obj = remotes[d.id];
  if (!obj){
    obj = remotes[d.id] = { state: makePlayer(false), history: [], lastSeen: performance.now() };
    obj.state.id = d.id;
    obj.state.name = d.name || d.id;
    rebuildHUD();
  }
  // update visual state
  obj.state.health = d.health;
  obj.state.dead = d.dead;
  obj.state.respawnTimer = d.respawnTimer || 0;
  obj.state.oobTimer = d.oobTimer || 0;
  if (d.name) obj.state.name = d.name;

  pushHistory(obj, {
    x: d.x, y: d.y, angle: d.angle, vx: d.vx, vy: d.vy,
    speed: d.speed, t: performance.now()
  });
});

/* ===========
   MAIN LOOP
   =========== */
let last = performance.now(), lastSent = 0;
function loop(now){
  const dt = Math.min(0.033, (now - last)/1000);
  last = now;

  // local update
  let slip = 0;
  if (!me.dead) slip = updateLocal(dt);
  else {
    me.respawnTimer -= dt;
    if (me.respawnTimer <= 0) respawn(me);
  }

  // remote interpolation & timers
  for (const id in remotes){
    const o = remotes[id];
    if (now - o.lastSeen > 10000){ delete remotes[id]; rebuildHUD(); continue; }
    const s = getInterpolatedState(o.history, now);
    if (s){
      o.state.x = s.x; o.state.y = s.y; o.state.angle = s.angle; o.state.vx = s.vx; o.state.vy = s.vy;
    }
    if (o.state.dead){
      o.state.respawnTimer -= dt;
      if (o.state.respawnTimer <= 0) respawn(o.state);
    }
    // decrement their oob timer visually if set (best-effort)
    if (o.state.oobTimer && o.state.oobTimer > 0) o.state.oobTimer = Math.max(0, o.state.oobTimer - dt);
  }

  // player-vs-player collisions
  for (const id in remotes){
    const rs = remotes[id].state;
    if (!rs.dead) collideLocalWithRemote(rs);
  }

  // death overlay for me
  if (me.health <= 0 && !me._flaggedDead){
    me._flaggedDead = true;
    killerText.textContent = `You were wrecked by ${me.killer ? (me.killer.slice ? me.killer.slice(0,6) : me.killer) : "the world"}`;
  }
  if (me.dead){
    respawnText.textContent = `Respawning in ${Math.ceil(me.respawnTimer)}…`;
    showDeadOverlay(true);
  } else {
    me._flaggedDead = false;
    showDeadOverlay(false);
  }

  // ===== RENDER =====
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const { camX, camY } = getCameraOffset();
  ctx.save();
  ctx.translate(-camX, -camY);

  // world background
  ctx.fillStyle = "#202225";
  ctx.fillRect(0,0,WORLD_W,WORLD_H);

  // border (thin red)
  drawBorder();

  // obstacles
  ctx.fillStyle = "#555";
  for (const o of obstacles) ctx.fillRect(o.x, o.y, o.w, o.h);

  // particles (world space)
  for (let i=particles.length-1;i>=0;i--){
    particles[i].update(); particles[i].draw();
    if (particles[i].life <= 0) particles.splice(i,1);
  }

  // cars + name tags
  if (!me.dead){
    const fwdX = Math.cos(me.angle), fwdY = Math.sin(me.angle);
    const sideX = -fwdY, sideY = fwdX;
    const vLat = me.vx*sideX + me.vy*sideY;
    drawCar(me.x, me.y, me.angle, vLat, carMe);
    drawNameTag(me.x, me.y, me.name, camX, camY);
  }
  for (const id in remotes){
    const r = remotes[id].state;
    if (r.dead) continue;
    const fwdX = Math.cos(r.angle), fwdY = Math.sin(r.angle);
    const sideX = -fwdY, sideY = fwdX;
    const vLat = (r.vx||0)*sideX + (r.vy||0)*sideY;
    drawCar(r.x, r.y, r.angle, vLat, carOther);
    drawNameTag(r.x, r.y, r.name || id.slice(0,6), camX, camY);
  }

  ctx.restore();

  // radar overlay (screen space)
  drawRadar();

  // OOB warning overlay (screen)
  if (me.oobTimer && me.oobTimer > 0 && !me.dead){
    const w = Math.max(0, Math.ceil(me.oobTimer));
    const el = document.getElementById('oobWarn');
    el.style.display = 'block';
    el.textContent = `Return to play area — ${w}s`;
  } else {
    const el = document.getElementById('oobWarn');
    el.style.display = 'none';
  }

  // HUD values
  updateHUDValues();

  // broadcast state (include name + oobTimer)
  if (now - lastSent > SEND_MS){
    channel.publish("player-state", {
      id: me.id, name: me.name,
      x: me.x, y: me.y, angle: me.angle,
      vx: me.vx, vy: me.vy,
      speed: Math.hypot(me.vx, me.vy),
      health: me.health, dead: me.dead,
      respawnTimer: me.respawnTimer,
      oobTimer: me.oobTimer || 0
    });
    lastSent = now;
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>

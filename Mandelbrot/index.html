<!DOCTYPE html>
<html>
<body style="margin:0; background:black; display:flex; justify-content:center; align-items:center; height:100vh;">
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById("canvas");
const gl = canvas.getContext("webgl2");

let center = {x: -0.5, y: 0};
let zoom = 1.0;

// Resize canvas and high-DPI support
function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const size = Math.min(window.innerWidth, window.innerHeight);
    canvas.style.width = size + "px";
    canvas.style.height = size + "px";
    canvas.width = size * dpr;
    canvas.height = size * dpr;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Vertex shader
const vertexShaderSource = `#version 300 es
in vec2 a_position;
void main() { gl_Position = vec4(a_position, 0.0, 1.0); }`;

// Fragment shader
const fragmentShaderSource = `#version 300 es
precision highp float;
out vec4 FragColor;
uniform vec2 iResolution;
uniform vec2 center;
uniform float zoom;
vec3 mandelbrot(vec2 c, int maxIter) {
    vec2 z = vec2(0.0);
    int i;
    for(i=0; i<maxIter; i++) {
        float x = (z.x*z.x - z.y*z.y) + c.x;
        float y = (2.0*z.x*z.y) + c.y;
        z = vec2(x, y);
        if(dot(z,z) > 4.0) break;
    }
    float t = float(i)/float(maxIter);
    return vec3(t, t*t, t*t*t);
}
void main() {
    vec2 uv = (gl_FragCoord.xy / iResolution) * 3.0 - vec2(2.0, 1.5);
    uv.x *= iResolution.x / iResolution.y;
    uv = center + uv / zoom;
    int maxIter = int(200.0 + 300.0*log2(zoom)); // more iterations as we zoom
    vec3 color = mandelbrot(uv, maxIter);
    FragColor = vec4(color, 1.0);
}`;

// Compile and create program
function compileShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(shader));
    return shader;
}
const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// Rectangle
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);
const positionLocation = gl.getAttribLocation(program, "a_position");
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

// Uniform locations
const resLoc = gl.getUniformLocation(program, "iResolution");
const centerLoc = gl.getUniformLocation(program, "center");
const zoomLoc = gl.getUniformLocation(program, "zoom");

// Controls: mouse wheel zoom, drag to move
let isDragging = false, lastX, lastY;
canvas.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
canvas.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mousemove', e => {
    if(isDragging) {
        let dx = (e.clientX - lastX) / canvas.width * 3.0 / zoom;
        let dy = (e.clientY - lastY) / canvas.height * 3.0 / zoom;
        dx *= canvas.width / canvas.height;
        center.x -= dx; 
        center.y += dy;
        lastX = e.clientX; lastY = e.clientY;
    }
});
canvas.addEventListener('wheel', e => {
    zoom *= e.deltaY < 0 ? 1.2 : 0.8;
});

// Animation loop
function render() {
    gl.uniform2f(resLoc, canvas.width, canvas.height);
    gl.uniform2f(centerLoc, center.x, center.y);
    gl.uniform1f(zoomLoc, zoom);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
}
render();
</script>
</body>
</html>

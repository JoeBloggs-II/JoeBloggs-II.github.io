<!DOCTYPE html>
<html lang="en">
<body style="margin:0; background:black; overflow:hidden;">
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const gl = canvas.getContext("webgl2");

if (!gl) alert("WebGL2 not supported");

/* ================= State ================= */

let center = { x: -0.5, y: 0.0 };
let zoom = 1.0;

/* ================= Resize ================= */

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width  = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener("resize", resize);
resize();

/* ================= Shaders ================= */

const vs = `#version 300 es
in vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}
`;

const fs = `#version 300 es
precision highp float;
out vec4 FragColor;

uniform vec2 iResolution;
uniform float zoom;
uniform vec2 centerHi;
uniform vec2 centerLo;

struct df { float hi; float lo; };

df df_make(float x){ return df(x,0.0); }

df df_add(df a, df b){
    float s = a.hi + b.hi;
    float v = s - a.hi;
    float t = ((b.hi - v) + (a.hi - (s - v))) + a.lo + b.lo;
    return df(s,t);
}

df df_sub(df a, df b){ return df_add(a, df(-b.hi, -b.lo)); }

df df_mul(df a, df b){
    float p = a.hi * b.hi;
    float e = a.hi*b.lo + a.lo*b.hi;
    return df(p,e);
}

float df_len2(df x, df y){
    return x.hi*x.hi + y.hi*y.hi;
}

int mandel_df(df cx, df cy, int maxIter){
    df zx = df_make(0.0);
    df zy = df_make(0.0);
    int i;
    for(i=0;i<maxIter;i++){
        df zx2 = df_mul(zx,zx);
        df zy2 = df_mul(zy,zy);
        zx = df_add(df_sub(zx2,zy2),cx);
        zy = df_add(df_mul(df_make(2.0),df_mul(zx,zy)),cy);
        if(df_len2(zx,zy) > 4.0) break;
    }
    return i;
}

vec3 palette(float t){
    t = clamp(t,0.0,1.0);
    return vec3(
        9.0*(1.0-t)*t*t*t,
        15.0*(1.0-t)*(1.0-t)*t*t,
        8.5*(1.0-t)*(1.0-t)*(1.0-t)*t
    );
}

void main(){
    vec2 uv = (gl_FragCoord.xy / iResolution) * 3.0 - vec2(2.0,1.5);
    uv.x *= iResolution.x / iResolution.y;

    int maxIter = int(200.0 + 300.0*log2(zoom));
    bool hiPrec = zoom > 1e6;
    int iter;

    if(!hiPrec){
        vec2 c = centerHi + uv/zoom;
        vec2 z = vec2(0.0);
        int i;
        for(i=0;i<maxIter;i++){
            z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
            if(dot(z,z) > 4.0) break;
        }
        iter = i;
    } else {
        df cx = df_add(df(centerHi.x,centerLo.x), df_make(uv.x/zoom));
        df cy = df_add(df(centerHi.y,centerLo.y), df_make(uv.y/zoom));
        iter = mandel_df(cx,cy,maxIter);
    }

    FragColor = vec4(palette(float(iter)/float(maxIter)),1.0);
}
`;

/* ================= Compile ================= */

function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
        throw gl.getShaderInfoLog(s);
    return s;
}

const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER,vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

/* ================= VAO (THE FIX) ================= */

const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1,  1,-1, -1, 1,
    -1, 1,  1,-1,  1, 1
]), gl.STATIC_DRAW);

const posLoc = gl.getAttribLocation(prog,"a_position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc,2,gl.FLOAT,false,0,0);

/* ================= Uniforms ================= */

const resLoc = gl.getUniformLocation(prog,"iResolution");
const zoomLoc = gl.getUniformLocation(prog,"zoom");
const hiLoc   = gl.getUniformLocation(prog,"centerHi");
const loLoc   = gl.getUniformLocation(prog,"centerLo");

/* ================= Precision split ================= */

function split(x){
    const hi = Math.fround(x);
    return { hi, lo: x-hi };
}

/* ================= Interaction ================= */

canvas.onwheel = e => {
    e.preventDefault();
    zoom *= e.deltaY < 0 ? 1.2 : 0.8;
};

let drag=false, px, py;
canvas.onmousedown=e=>{ drag=true; px=e.clientX; py=e.clientY; };
onmouseup=()=>drag=false;
onmousemove=e=>{
    if(!drag) return;
    center.x -= (e.clientX-px)/canvas.width*3.0/zoom;
    center.y += (e.clientY-py)/canvas.height*3.0/zoom;
    px=e.clientX; py=e.clientY;
};

/* ================= Render ================= */

function render(){
    gl.bindVertexArray(vao);

    const cx = split(center.x);
    const cy = split(center.y);

    gl.uniform2f(resLoc,canvas.width,canvas.height);
    gl.uniform1f(zoomLoc,zoom);
    gl.uniform2f(hiLoc,cx.hi,cy.hi);
    gl.uniform2f(loLoc,cx.lo,cy.lo);

    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
